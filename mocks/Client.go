// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	context "context"

	indexer "github.com/nervosnetwork/ckb-sdk-go/indexer"
	mock "github.com/stretchr/testify/mock"

	types "github.com/nervosnetwork/ckb-sdk-go/types"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

func (_m *Client) GetTransactionProof(ctx context.Context, txHashes []string, blockHash *types.Hash) (*types.TransactionProof, error) {
	panic("implement me")
}

func (_m *Client) VerifyTransactionProof(ctx context.Context, proof *types.TransactionProof) ([]*types.Hash, error) {
	panic("implement me")
}

func (_m *Client) GetForkBlock(ctx context.Context, blockHash types.Hash) (*types.Block, error) {
	panic("implement me")
}

func (_m *Client) GetBlockMedianTime(ctx context.Context, blockHash types.Hash) (uint64, error) {
	panic("implement me")
}

func (_m *Client) ClearBannedAddresses(ctx context.Context) error {
	panic("implement me")
}

func (_m *Client) SyncState(ctx context.Context) (*types.SyncState, error) {
	panic("implement me")
}

func (_m *Client) SetNetworkActive(ctx context.Context, state bool) error {
	panic("implement me")
}

func (_m *Client) AddNode(ctx context.Context, peerId, address string) error {
	panic("implement me")
}

func (_m *Client) RemoveNode(ctx context.Context, peerId string) error {
	panic("implement me")
}

func (_m *Client) PingPeers(ctx context.Context) error {
	panic("implement me")
}

func (_m *Client) GetRawTxPool(ctx context.Context) (*types.RawTxPool, error) {
	panic("implement me")
}

func (_m *Client) ClearTxPool(ctx context.Context) error {
	panic("implement me")
}

// BatchLiveCells provides a mock function with given fields: ctx, batch
func (_m *Client) BatchLiveCells(ctx context.Context, batch []types.BatchLiveCellItem) error {
	ret := _m.Called(ctx, batch)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []types.BatchLiveCellItem) error); ok {
		r0 = rf(ctx, batch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BatchTransactions provides a mock function with given fields: ctx, batch
func (_m *Client) BatchTransactions(ctx context.Context, batch []types.BatchTransactionItem) error {
	ret := _m.Called(ctx, batch)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []types.BatchTransactionItem) error); ok {
		r0 = rf(ctx, batch)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CalculateDaoMaximumWithdraw provides a mock function with given fields: ctx, point, hash
func (_m *Client) CalculateDaoMaximumWithdraw(ctx context.Context, point *types.OutPoint, hash types.Hash) (uint64, error) {
	ret := _m.Called(ctx, point, hash)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, *types.OutPoint, types.Hash) uint64); ok {
		r0 = rf(ctx, point, hash)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.OutPoint, types.Hash) error); ok {
		r1 = rf(ctx, point, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CallContext provides a mock function with given fields: ctx, result, method, args
func (_m *Client) CallContext(ctx context.Context, result interface{}, method string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, ctx, result, method)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interface{}, string, ...interface{}) error); ok {
		r0 = rf(ctx, result, method, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *Client) Close() {
	_m.Called()
}

// DryRunTransaction provides a mock function with given fields: ctx, transaction
func (_m *Client) DryRunTransaction(ctx context.Context, transaction *types.Transaction) (*types.DryRunTransactionResult, error) {
	ret := _m.Called(ctx, transaction)

	var r0 *types.DryRunTransactionResult
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction) *types.DryRunTransactionResult); ok {
		r0 = rf(ctx, transaction)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.DryRunTransactionResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction) error); ok {
		r1 = rf(ctx, transaction)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EstimateFeeRate provides a mock function with given fields: ctx, blocks
func (_m *Client) EstimateFeeRate(ctx context.Context, blocks uint64) (*types.EstimateFeeRateResult, error) {
	ret := _m.Called(ctx, blocks)

	var r0 *types.EstimateFeeRateResult
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.EstimateFeeRateResult); ok {
		r0 = rf(ctx, blocks)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.EstimateFeeRateResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, blocks)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBannedAddresses provides a mock function with given fields: ctx
func (_m *Client) GetBannedAddresses(ctx context.Context) ([]*types.BannedAddress, error) {
	ret := _m.Called(ctx)

	var r0 []*types.BannedAddress
	if rf, ok := ret.Get(0).(func(context.Context) []*types.BannedAddress); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.BannedAddress)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlock provides a mock function with given fields: ctx, hash
func (_m *Client) GetBlock(ctx context.Context, hash types.Hash) (*types.Block, error) {
	ret := _m.Called(ctx, hash)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func(context.Context, types.Hash) *types.Block); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockByNumber provides a mock function with given fields: ctx, number
func (_m *Client) GetBlockByNumber(ctx context.Context, number uint64) (*types.Block, error) {
	ret := _m.Called(ctx, number)

	var r0 *types.Block
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.Block); ok {
		r0 = rf(ctx, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Block)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, number)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockEconomicState provides a mock function with given fields: ctx, hash
func (_m *Client) GetBlockEconomicState(ctx context.Context, hash types.Hash) (*types.BlockEconomicState, error) {
	ret := _m.Called(ctx, hash)

	var r0 *types.BlockEconomicState
	if rf, ok := ret.Get(0).(func(context.Context, types.Hash) *types.BlockEconomicState); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockEconomicState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockHash provides a mock function with given fields: ctx, number
func (_m *Client) GetBlockHash(ctx context.Context, number uint64) (*types.Hash, error) {
	ret := _m.Called(ctx, number)

	var r0 *types.Hash
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.Hash); ok {
		r0 = rf(ctx, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, number)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockchainInfo provides a mock function with given fields: ctx
func (_m *Client) GetBlockchainInfo(ctx context.Context) (*types.BlockchainInfo, error) {
	ret := _m.Called(ctx)

	var r0 *types.BlockchainInfo
	if rf, ok := ret.Get(0).(func(context.Context) *types.BlockchainInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockchainInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCellbaseOutputCapacityDetails provides a mock function with given fields: ctx, hash
func (_m *Client) GetCellbaseOutputCapacityDetails(ctx context.Context, hash types.Hash) (*types.BlockReward, error) {
	ret := _m.Called(ctx, hash)

	var r0 *types.BlockReward
	if rf, ok := ret.Get(0).(func(context.Context, types.Hash) *types.BlockReward); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockReward)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCells provides a mock function with given fields: ctx, searchKey, order, limit, afterCursor
func (_m *Client) GetCells(ctx context.Context, searchKey *indexer.SearchKey, order indexer.SearchOrder, limit uint64, afterCursor string) (*indexer.LiveCells, error) {
	ret := _m.Called(ctx, searchKey, order, limit, afterCursor)

	var r0 *indexer.LiveCells
	if rf, ok := ret.Get(0).(func(context.Context, *indexer.SearchKey, indexer.SearchOrder, uint64, string) *indexer.LiveCells); ok {
		r0 = rf(ctx, searchKey, order, limit, afterCursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*indexer.LiveCells)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *indexer.SearchKey, indexer.SearchOrder, uint64, string) error); ok {
		r1 = rf(ctx, searchKey, order, limit, afterCursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCellsCapacity provides a mock function with given fields: ctx, searchKey
func (_m *Client) GetCellsCapacity(ctx context.Context, searchKey *indexer.SearchKey) (*indexer.Capacity, error) {
	ret := _m.Called(ctx, searchKey)

	var r0 *indexer.Capacity
	if rf, ok := ret.Get(0).(func(context.Context, *indexer.SearchKey) *indexer.Capacity); ok {
		r0 = rf(ctx, searchKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*indexer.Capacity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *indexer.SearchKey) error); ok {
		r1 = rf(ctx, searchKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConsensus provides a mock function with given fields: ctx
func (_m *Client) GetConsensus(ctx context.Context) (*types.Consensus, error) {
	ret := _m.Called(ctx)

	var r0 *types.Consensus
	if rf, ok := ret.Get(0).(func(context.Context) *types.Consensus); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Consensus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentEpoch provides a mock function with given fields: ctx
func (_m *Client) GetCurrentEpoch(ctx context.Context) (*types.Epoch, error) {
	ret := _m.Called(ctx)

	var r0 *types.Epoch
	if rf, ok := ret.Get(0).(func(context.Context) *types.Epoch); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Epoch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEpochByNumber provides a mock function with given fields: ctx, number
func (_m *Client) GetEpochByNumber(ctx context.Context, number uint64) (*types.Epoch, error) {
	ret := _m.Called(ctx, number)

	var r0 *types.Epoch
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.Epoch); ok {
		r0 = rf(ctx, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Epoch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, number)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHeader provides a mock function with given fields: ctx, hash
func (_m *Client) GetHeader(ctx context.Context, hash types.Hash) (*types.Header, error) {
	ret := _m.Called(ctx, hash)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(context.Context, types.Hash) *types.Header); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHeaderByNumber provides a mock function with given fields: ctx, number
func (_m *Client) GetHeaderByNumber(ctx context.Context, number uint64) (*types.Header, error) {
	ret := _m.Called(ctx, number)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *types.Header); ok {
		r0 = rf(ctx, number)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, number)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLiveCell provides a mock function with given fields: ctx, outPoint, withData
func (_m *Client) GetLiveCell(ctx context.Context, outPoint *types.OutPoint, withData bool) (*types.CellWithStatus, error) {
	ret := _m.Called(ctx, outPoint, withData)

	var r0 *types.CellWithStatus
	if rf, ok := ret.Get(0).(func(context.Context, *types.OutPoint, bool) *types.CellWithStatus); ok {
		r0 = rf(ctx, outPoint, withData)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.CellWithStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.OutPoint, bool) error); ok {
		r1 = rf(ctx, outPoint, withData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPeers provides a mock function with given fields: ctx
func (_m *Client) GetPeers(ctx context.Context) ([]*types.RemoteNode, error) {
	ret := _m.Called(ctx)

	var r0 []*types.RemoteNode
	if rf, ok := ret.Get(0).(func(context.Context) []*types.RemoteNode); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.RemoteNode)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTip provides a mock function with given fields: ctx
func (_m *Client) GetTip(ctx context.Context) (*indexer.TipHeader, error) {
	ret := _m.Called(ctx)

	var r0 *indexer.TipHeader
	if rf, ok := ret.Get(0).(func(context.Context) *indexer.TipHeader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*indexer.TipHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTipBlockNumber provides a mock function with given fields: ctx
func (_m *Client) GetTipBlockNumber(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTipHeader provides a mock function with given fields: ctx
func (_m *Client) GetTipHeader(ctx context.Context) (*types.Header, error) {
	ret := _m.Called(ctx)

	var r0 *types.Header
	if rf, ok := ret.Get(0).(func(context.Context) *types.Header); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransaction provides a mock function with given fields: ctx, hash
func (_m *Client) GetTransaction(ctx context.Context, hash types.Hash) (*types.TransactionWithStatus, error) {
	ret := _m.Called(ctx, hash)

	var r0 *types.TransactionWithStatus
	if rf, ok := ret.Get(0).(func(context.Context, types.Hash) *types.TransactionWithStatus); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TransactionWithStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.Hash) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactions provides a mock function with given fields: ctx, searchKey, order, limit, afterCursor
func (_m *Client) GetTransactions(ctx context.Context, searchKey *indexer.SearchKey, order indexer.SearchOrder, limit uint64, afterCursor string) (*indexer.Transactions, error) {
	ret := _m.Called(ctx, searchKey, order, limit, afterCursor)

	var r0 *indexer.Transactions
	if rf, ok := ret.Get(0).(func(context.Context, *indexer.SearchKey, indexer.SearchOrder, uint64, string) *indexer.Transactions); ok {
		r0 = rf(ctx, searchKey, order, limit, afterCursor)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*indexer.Transactions)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *indexer.SearchKey, indexer.SearchOrder, uint64, string) error); ok {
		r1 = rf(ctx, searchKey, order, limit, afterCursor)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalNodeInfo provides a mock function with given fields: ctx
func (_m *Client) LocalNodeInfo(ctx context.Context) (*types.LocalNode, error) {
	ret := _m.Called(ctx)

	var r0 *types.LocalNode
	if rf, ok := ret.Get(0).(func(context.Context) *types.LocalNode); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.LocalNode)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransaction provides a mock function with given fields: ctx, tx
func (_m *Client) SendTransaction(ctx context.Context, tx *types.Transaction) (*types.Hash, error) {
	ret := _m.Called(ctx, tx)

	var r0 *types.Hash
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction) *types.Hash); ok {
		r0 = rf(ctx, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction) error); ok {
		r1 = rf(ctx, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendTransactionNoneValidation provides a mock function with given fields: ctx, tx
func (_m *Client) SendTransactionNoneValidation(ctx context.Context, tx *types.Transaction) (*types.Hash, error) {
	ret := _m.Called(ctx, tx)

	var r0 *types.Hash
	if rf, ok := ret.Get(0).(func(context.Context, *types.Transaction) *types.Hash); ok {
		r0 = rf(ctx, tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Hash)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Transaction) error); ok {
		r1 = rf(ctx, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetBan provides a mock function with given fields: ctx, address, command, banTime, absolute, reason
func (_m *Client) SetBan(ctx context.Context, address string, command string, banTime uint64, absolute bool, reason string) error {
	ret := _m.Called(ctx, address, command, banTime, absolute, reason)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64, bool, string) error); ok {
		r0 = rf(ctx, address, command, banTime, absolute, reason)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TxPoolInfo provides a mock function with given fields: ctx
func (_m *Client) TxPoolInfo(ctx context.Context) (*types.TxPoolInfo, error) {
	ret := _m.Called(ctx)

	var r0 *types.TxPoolInfo
	if rf, ok := ret.Get(0).(func(context.Context) *types.TxPoolInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TxPoolInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
